You are absolutely right to question this behavior. The logs show that your system is **pausing** (blocking) instead of running continuously.

### üî¥ The Problem: "Blocking" vs. "Parallel"

Currently, your `run_data_factory.py` runs a single loop. It does this:

1.  Get Binance Data (Fast)
2.  **Call Delta API (Slow/Timeout)** -\> **The whole script stops here for 10-30 seconds\!**
3.  Save to Database.

This explains why you see `Row 10`, then `Row 20`, then a long pause, then `Row 30`. You are losing valuable market data during those pauses.

### ‚úÖ The Solution: Multi-Threading

We need to move the slow APIs (Delta, News, Etherscan) into **Background Threads**. They will run at their own speed without stopping the main "Heartbeat" loop.

Here are the **4 Files** you need to update to fix the blocking issue and the Web UI crash.

-----

### 1\. Update `infrastructure/key_manager.py` (Fix Web UI Crash)

**Issue:** The variable name `"keys"` conflicts with the Python dictionary method `.keys()`, causing the 500 Error.
**Fix:** Rename it to `"key_list"`.

```python
"""
Smart API Key Manager with Rotation Logic
"""
import time
import threading
from datetime import datetime
from typing import Dict, List, Optional, Any
from collections import defaultdict
import json

class KeyManager:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.lock = threading.Lock()
        
        # Track usage for each service
        self.usage = {
            "binance": {"index": 0, "count": 0, "reset_time": time.time()},
            "delta": {"index": 0, "count": 0, "reset_time": time.time()},
            "cryptopanic": {"index": 0, "count": 0, "reset_time": self._get_month_start()},
            "etherscan": {"index": 0, "count": 0, "reset_time": self._get_day_start()},
            "alphavantage": {"index": 0, "count": 0, "reset_time": self._get_day_start()},
            "fred": {"index": 0, "count": 0, "reset_time": time.time()},
            "coingecko": {"index": 0, "count": 0, "reset_time": self._get_month_start()}
        }
        self.key_usage = defaultdict(lambda: {"count": 0, "last_reset": time.time()})
        self.proxy_index = 0
        print("‚úÖ KeyManager initialized")

    def _get_day_start(self) -> float:
        now = datetime.utcnow()
        return datetime(now.year, now.month, now.day).timestamp()
    
    def _get_month_start(self) -> float:
        now = datetime.utcnow()
        return datetime(now.year, now.month, 1).timestamp()

    def get_key(self, service: str) -> Optional[Dict[str, Any]]:
        with self.lock:
            keys = self.config.get(f"{service}_keys", [])
            if not keys: return None
            self._check_and_reset(service)
            return keys[self.usage[service]["index"]]

    def increment(self, service: str) -> bool:
        with self.lock:
            keys = self.config.get(f"{service}_keys", [])
            if not keys: return False
            
            meta = self.usage[service]
            key = keys[meta["index"]]
            limit = self._get_limit(service, key)
            
            self._check_and_reset(service)
            
            if meta["count"] >= limit * 0.95:
                if self._rotate_key(service):
                    print(f"üîÑ Rotated {service} key")
                else:
                    return False
            
            meta["count"] += 1
            key_id = self._get_key_id(service, key)
            self.key_usage[key_id]["count"] += 1
            return True

    def _get_limit(self, service: str, key: Dict) -> int:
        if service == "binance": return key.get("limit", 1200)
        if service == "delta": return key.get("limit", 50)
        if service == "cryptopanic": return key.get("monthly_limit", 100)
        if service == "etherscan": return key.get("daily_limit", 100000)
        if service == "alphavantage": return key.get("daily_limit", 25)
        if service == "fred": return key.get("limit", 120)
        if service == "coingecko": return key.get("monthly_limit", 10000)
        return 0

    def _get_key_id(self, service: str, key: Dict) -> str:
        if service in ["binance", "delta"]:
            return f"{service}_{key.get('api_key', '')[:8]}"
        token = key.get('token') or key.get('api_key', '')
        return f"{service}_{token[:8]}"

    def _check_and_reset(self, service: str):
        meta = self.usage[service]
        now = time.time()
        
        if service in ["binance", "delta", "fred"]:
            if now - meta["reset_time"] > 60:
                meta["count"] = 0
                meta["reset_time"] = now
        elif service in ["etherscan", "alphavantage"]:
            if now >= self._get_day_start() + 86400:
                meta["count"] = 0
                meta["reset_time"] = self._get_day_start()
        elif service in ["cryptopanic", "coingecko"]:
            if meta["reset_time"] < self._get_month_start():
                meta["count"] = 0
                meta["reset_time"] = self._get_month_start()

    def _rotate_key(self, service: str) -> bool:
        keys = self.config.get(f"{service}_keys", [])
        if len(keys) <= 1: return False
        
        meta = self.usage[service]
        original_idx = meta["index"]
        
        for _ in range(len(keys)):
            meta["index"] = (meta["index"] + 1) % len(keys)
            new_key = keys[meta["index"]]
            key_id = self._get_key_id(service, new_key)
            limit = self._get_limit(service, new_key)
            
            if self.key_usage[key_id]["count"] < limit * 0.95:
                meta["count"] = self.key_usage[key_id]["count"]
                return True
        
        meta["index"] = original_idx
        return False

    def get_proxy(self) -> Optional[Dict[str, Any]]:
        with self.lock:
            proxies = self.config.get("proxies", [])
            if not proxies: return None
            proxy = proxies[self.proxy_index]
            self.proxy_index = (self.proxy_index + 1) % len(proxies)
            return proxy

    def get_proxy_dict(self) -> Optional[Dict[str, str]]:
        proxy = self.get_proxy()
        if not proxy: return None
        url = f"http://{proxy['username']}:{proxy['password']}@{proxy['host']}:{proxy['port']}"
        return {"http": url, "https": url}

    def get_status(self) -> Dict[str, Any]:
        with self.lock:
            status = {}
            for service in ["delta", "cryptopanic", "etherscan", "alphavantage", "fred", "coingecko"]:
                keys = self.config.get(f"{service}_keys", [])
                if not keys: continue
                
                service_status = {
                    "total_keys": len(keys),
                    "current_key_index": self.usage[service]["index"],
                    "total_requests": self.usage[service]["count"],
                    "key_list": []  # <--- RENAMED FROM 'keys' TO 'key_list'
                }
                
                for i, key in enumerate(keys):
                    key_id = self._get_key_id(service, key)
                    limit = self._get_limit(service, key)
                    used = self.key_usage[key_id]["count"]
                    
                    service_status["key_list"].append({
                        "index": i,
                        "active": i == self.usage[service]["index"],
                        "used": used,
                        "limit": limit,
                        "percentage": round((used / limit * 100) if limit > 0 else 0, 2),
                        "status": "OK" if used < limit * 0.8 else "WARNING"
                    })
                status[service] = service_status
            return status
```

-----

### 2\. Update `data_layer/collectors_other.py` (Enable Threading)

**Issue:** These collectors were blocking the main loop.
**Fix:** Convert them to run in background threads.

```python
"""
Other Data Collectors - THREADED VERSION
"""
import requests
import time
import threading
from typing import Dict, Any

class ThreadedCollector(threading.Thread):
    def __init__(self):
        super().__init__()
        self.daemon = True
        self.running = False
        self.lock = threading.Lock()
        self.latest_data = {}

    def get_snapshot(self) -> Dict[str, Any]:
        with self.lock: return self.latest_data.copy()

    def stop(self): self.running = False

class DeltaExchangeCollector(ThreadedCollector):
    def __init__(self, key_manager):
        super().__init__()
        self.key_manager = key_manager
        self.base_url = "https://api.delta.exchange"
        self.latest_data = {"implied_volatility": None, "delta_exposure": None, "theta": None, "vega": None, "open_interest": None}
        print("‚úÖ DeltaExchangeCollector (Threaded) initialized")
    
    def run(self):
        self.running = True
        while self.running:
            self.fetch_ticker()
            time.sleep(10)

    def fetch_ticker(self, symbol: str = "BTCUSD"):
        if not self.key_manager.increment("delta"): return
        try:
            key = self.key_manager.get_key("delta")
            if not key: return
            proxies = self.key_manager.get_proxy_dict()
            resp = requests.get(f"{self.base_url}/v2/tickers/{symbol}", proxies=proxies, timeout=5)
            if resp.status_code == 200:
                data = resp.json().get('result', {})
                greeks = data.get('greeks') or {}
                with self.lock:
                    self.latest_data["implied_volatility"] = greeks.get('iv')
                    self.latest_data["delta_exposure"] = greeks.get('delta')
                    self.latest_data["theta"] = greeks.get('theta')
                    self.latest_data["vega"] = greeks.get('vega')
                    self.latest_data["open_interest"] = data.get('oi_value_usd')
        except Exception: pass

class CryptoPanicCollector(ThreadedCollector):
    def __init__(self, key_manager):
        super().__init__()
        self.key_manager = key_manager
        self.base_url = "https://cryptopanic.com/api/developer/v2"
        self.latest_data = {"news_sentiment": 0.0, "news_count": 0}
        print("‚úÖ CryptoPanicCollector (Threaded) initialized")

    def run(self):
        self.running = True
        while self.running:
            self.fetch_news()
            time.sleep(300)

    def fetch_news(self):
        if not self.key_manager.increment("cryptopanic"): return
        try:
            key = self.key_manager.get_key("cryptopanic")
            if not key: return
            resp = requests.get(f"{self.base_url}/posts/", params={"auth_token": key["token"], "currencies": "BTC", "kind": "news", "filter": "rising"}, timeout=10)
            if resp.status_code == 200:
                results = resp.json().get('results', [])
                scores = []
                for item in results[:20]:
                    votes = item.get('votes', {})
                    pos, neg = votes.get('positive', 0), votes.get('negative', 0)
                    if pos + neg > 0: scores.append((pos - neg) / (pos + neg))
                with self.lock:
                    if scores: self.latest_data["news_sentiment"] = sum(scores) / len(scores)
        except Exception: pass

class AlphaVantageCollector(ThreadedCollector):
    def __init__(self, key_manager):
        super().__init__()
        self.key_manager = key_manager
        self.base_url = "https://www.alphavantage.co/query"
        self.latest_data = {"social_hype_index": 0.0}
        print("‚úÖ AlphaVantageCollector (Threaded) initialized")

    def run(self):
        self.running = True
        while self.running:
            self.fetch_sentiment()
            time.sleep(1800)

    def fetch_sentiment(self):
        if not self.key_manager.increment("alphavantage"): return
        try:
            key = self.key_manager.get_key("alphavantage")
            if not key: return
            resp = requests.get(self.base_url, params={"function": "NEWS_SENTIMENT", "tickers": "CRYPTO:BTC", "apikey": key["api_key"], "limit": 50}, timeout=10)
            if resp.status_code == 200:
                feed = resp.json().get('feed', [])
                scores = [float(ts.get('ticker_sentiment_score', 0)) for a in feed for ts in a.get('ticker_sentiment', []) if ts.get('ticker') == "CRYPTO:BTC"]
                with self.lock:
                    if scores: self.latest_data["social_hype_index"] = sum(scores) / len(scores)
        except Exception: pass

class EtherscanCollector(ThreadedCollector):
    def __init__(self, key_manager):
        super().__init__()
        self.key_manager = key_manager
        self.base_url = "https://api.etherscan.io/api"
        self.latest_data = {"whale_inflow": 0.0}
        self.wallets = ["0x28c6c06298d514db089934071355e5743bf21d60", "0x21a31ee1afc51d94c2efccaa2092ad1028285549"]
        print("‚úÖ EtherscanCollector (Threaded) initialized")

    def run(self):
        self.running = True
        while self.running:
            self.fetch_whale()
            time.sleep(60)

    def fetch_whale(self):
        if not self.key_manager.increment("etherscan"): return
        try:
            key = self.key_manager.get_key("etherscan")
            if not key: return
            total = 0
            for w in self.wallets:
                resp = requests.get(self.base_url, params={"module": "account", "action": "balance", "address": w, "apikey": key["api_key"]}, timeout=10)
                if resp.status_code == 200 and resp.json().get('status') == '1':
                    total += int(resp.json().get('result', 0)) / 1e18
                time.sleep(0.4)
            with self.lock: self.latest_data["whale_inflow"] = total
        except Exception: pass

class AlternativeMeCollector(ThreadedCollector):
    def __init__(self):
        super().__init__()
        self.latest_data = {"fear_greed_index": 50}
        print("‚úÖ AlternativeMeCollector (Threaded) initialized")

    def run(self):
        self.running = True
        while self.running:
            try:
                resp = requests.get("https://api.alternative.me/fng/", timeout=10)
                if resp.status_code == 200:
                    data = resp.json()
                    if data.get('data'):
                        with self.lock: self.latest_data["fear_greed_index"] = int(data['data'][0].get('value', 50))
            except Exception: pass
            time.sleep(1800)
```

-----

### 3\. Update `run_data_factory.py` (Start Threads)

**Issue:** Needs to start the new threads and remove blocking calls from main loop.

```python
"""
CRYPTO DATA FACTORY - Main Orchestration Script
"""
import time
import threading
import signal
from datetime import datetime
from config.api_key_parser import APIKeyParser
from infrastructure.key_manager import KeyManager
from infrastructure.timescale_db import TimescaleDB
from data_layer.collectors_binance import BinanceWebSocketCollector, BinanceRESTCollector
from data_layer.collectors_other import (
    DeltaExchangeCollector, CryptoPanicCollector, AlphaVantageCollector,
    EtherscanCollector, AlternativeMeCollector
)
from web_ui.status_server import run_server, update_status

shutdown_event = threading.Event()

def signal_handler(sig, frame):
    print("\n\n‚ö†Ô∏è  Shutdown signal received...")
    shutdown_event.set()

def main():
    print("üöÄ CRYPTO DATA FACTORY - STARTING UP")
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    parser = APIKeyParser(apikey_file="apikey.txt")
    config = parser.parse()
    parser.add_proxies_from_file("iproyal-proxies.txt")
    
    key_manager = KeyManager(config)
    db = TimescaleDB()
    
    # Initialize Collectors
    binance_ws = BinanceWebSocketCollector(symbol="btcusdt", proxy_manager=key_manager)
    binance_rest = BinanceRESTCollector(symbol="BTCUSDT", key_manager=key_manager)
    
    # Threaded Collectors
    delta = DeltaExchangeCollector(key_manager)
    cryptopanic = CryptoPanicCollector(key_manager)
    alphavantage = AlphaVantageCollector(key_manager)
    etherscan = EtherscanCollector(key_manager)
    alternative_me = AlternativeMeCollector()
    
    collectors_status = {
        "Binance WebSocket": "starting", "Delta": "running", "News": "running"
    }
    
    # Start Threads
    threading.Thread(target=binance_ws.run, daemon=True).start()
    delta.start()
    cryptopanic.start()
    alphavantage.start()
    etherscan.start()
    alternative_me.start()
    
    # Start UI
    threading.Thread(target=run_server, kwargs={"host": "0.0.0.0", "port": 5000}, daemon=True).start()
    
    print("‚úÖ ALL SYSTEMS ONLINE - DATA COLLECTION STARTED")
    
    iteration = 0
    while not shutdown_event.is_set():
        try:
            iteration += 1
            row = {"timestamp": datetime.now(), "symbol": "BTCUSDT"}
            
            # 1. Get Real-time Data (Instant)
            row.update(binance_ws.get_snapshot())
            row.update(delta.get_snapshot())
            row.update(cryptopanic.get_snapshot())
            row.update(alphavantage.get_snapshot())
            row.update(etherscan.get_snapshot())
            row.update(alternative_me.get_snapshot())
            
            # 2. Get Periodic Binance REST Data (every 60s)
            if iteration % 60 == 0:
                binance_rest.fetch_funding_rate()
                binance_rest.fetch_open_interest()
                row.update(binance_rest.get_snapshot())
            
            # 3. Save
            if row.get("timestamp"):
                db.insert_single(row)
                if iteration % 10 == 0:
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] üíæ Row {iteration} saved | Price: ${row.get('close', 0):.2f}")
            
            if iteration % 5 == 0:
                update_status(key_manager, db, collectors_status)
            
            time.sleep(1)
            
        except Exception as e:
            print(f"‚ùå Error: {e}")
            time.sleep(1)

    binance_ws.stop()
    db.close()

if __name__ == "__main__":
    main()
```

-----

### 4\. Update `web_ui/status_server.py` (Match New Key Name)

**Issue:** Template tried to iterate a method.
**Fix:** Use `key_list` (which we renamed in step 1).

```python
"""
Simple Web UI for Monitoring API Status
"""
from flask import Flask, jsonify, render_template_string
from flask_cors import CORS
import threading
import time

app = Flask(__name__)
CORS(app)

API_STATUS = {
    "last_updated": None, "services": {}, 
    "database": {"status": "unknown", "rows": 0}, "collectors": {}
}

HTML_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>Crypto Factory Status</title>
    <meta http-equiv="refresh" content="5">
    <style>body{font-family:sans-serif;background:#1a1a1a;color:#fff;padding:20px} .ok{color:#0f0} .err{color:#f00}</style>
</head>
<body>
    <h1>üöÄ Status Dashboard</h1>
    <p>Last Update: {{ last_updated }}</p>
    <p>DB Rows: {{ db_rows }}</p>
    
    {% for service, data in services.items() %}
    <div style="border:1px solid #444; margin:10px; padding:10px">
        <h3>{{ service|upper }}</h3>
        <p>Requests: {{ data.total_requests }}</p>
        {% for key in data.key_list %} <div>Key #{{ key.index }}: {{ key.used }}/{{ key.limit }} ({{ key.status }})</div>
        {% endfor %}
    </div>
    {% endfor %}
</body>
</html>
"""

@app.route('/')
def dashboard():
    return render_template_string(HTML_TEMPLATE, **API_STATUS)

def update_status(km, db, cols):
    global API_STATUS
    API_STATUS.update({
        "last_updated": time.strftime("%H:%M:%S"),
        "services": km.get_status() if km else {},
        "database": {"rows": db.query("SELECT count(*) as c FROM feature_store")[0]['c'] if db else 0},
        "collectors": cols
    })

def run_server(host='0.0.0.0', port=5000):
    app.run(host=host, port=port, debug=False, use_reloader=False)
```